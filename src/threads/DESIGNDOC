			+--------------------+
			|         OS         |
			| PROJECT 1: THREADS |
			|   DESIGN DOCUMENT  |
			+--------------------+
				   
---- GROUP ----

Tobias Orth <tobiasorth@gmx.net>
Mirjam Neu-Weigand <mirjam.neuweigand@gmail.com>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

None.

			     ALARM CLOCK
			     ===========

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

Added to struct thread in thread.h:

struct thread 
{
	...
	
	struct list_elem sleepelem; 		/* List element for sleeping threads list. */
	static struct list sleeping_list; 	/* List of sleeping threads */
	
	...
}

---- ALGORITHMS ----

>> A2: Briefly describe what happens in a call to timer_sleep(),
>> including the effects of the timer interrupt handler.

In a call to timer_sleep(ticks) we invoke thread_sleep(ticks), 
which assigns the thread a future tick count, depending on the 
current overall tick counter (kernel + idle + user). After that, 
the thread is added to the list of sleeping threads.

If the scheduler calls next_thread_to_run(), the sleeping threads
are checked. If any of them has a tick count less or equal the current
tick counter, it is waken. In this case, the waken thread is 
pushed to the front of the list. This ensures that the time 
between waking the thread and running the thread again is minimized.

>> A3: What steps are taken to minimize the amount of time spent in
>> the timer interrupt handler?

No further action is needed on the timer interrupt handler side, 
everything is done while scheduling.


---- SYNCHRONIZATION ----

>> A4: How are race conditions avoided when multiple threads call
>> timer_sleep() simultaneously?

As every thread has its own data / sleep time, no race conditions occur.

>> A5: How are race conditions avoided when a timer interrupt occurs
>> during a call to timer_sleep()?

As mentioned earlier, due to the thread implementation, no
race condition can occur.


---- RATIONALE ----

>> A6: Why did you choose this design?  In what ways is it superior to
>> another design you considered?

As we are using thread mechanics to schedule the sleeping, out 
implementation should be more efficient than a pure timer 
implementation. The main functionality equals thread_yield() but
instead of adding it to the ready queue it is added to the sleeping
queue. As the scheduler pushs the sleeping threads to the front of 
the queue (after the thread slept x ticks), the waken threads
are prioritized over the normal ones. 


	  		     PROD/CONS
	  		     =========

---- SYNCHRONIZATION ----

>> B1: How does your solution guarantee that consumers will hold until
>> there is something to consume in the buffer?

Our solution guarantees that consumers hold until there is something to consume in the buffer by checking the current positions of the first and last character in the buffer. If those are equal and there has been no wrap-around in the meantime, there is nothing to read in the buffer and the consumer has to wait for being signaled by a producer thread. When this happens, we check again the condition to ensure that no other consumer thread has taken the lock before we continue.

>> B2: How does your solution guarantee that producers will hold until
>> there is some free space in the buffer?

Producer threads also check the current positions of the first and the last character in the buffer. If those are equal and there has been a wrap-around, we know that the buffer is full and wait until a consumer signals that there is some free space again. Then we recheck the condition and proceed only if it is still fulfilled.

>> B3: How does your solution preserve a FIFO semantics i.e., the first
>> character produced will be the first to be consumed?

This is implemented by keeping the current position of the first and last character and protecting this information with a lock. 

---- RATIONALE ----

>> B4: Give an intuition for why your program preserves safety.

Our program implements a monitor which protects the variables with a lock and uses condition variables to synchronize the threads. Variables are only manipulated if the current thread holds the lock. Invoking a wait() means that the thread returns the lock and has to reacquire it after he is being signaled. By checking again the condition with a while-loop we achieve that no two threads can exist in the chritical section at the same time. 

>> B5: Why did you choose this design? Did you consider other design 
>> alternatives? In what ways is it superior to another design you considered?

We first used a linked-list which caused problems at initialization and when getting and putting elements in it. After that, we decided to switch to a more pure and better understable design with a char-array. A good structure of checking and rechecking conditions before acquiring a lock helped us to achieve the goal of synchronization without interference.

			     NARROW BRIDGE
			     =============

---- SYNCHRONIZATION ----

>> C1: How does your solution guarantee that no more than 3 vehicles 
>> are crossing the bridge in the same direction?

We use a semaphore that is initialized with 3 to ensure that only 3 vehicles can cross the bridge. In the method arrive_bridge(int direc, int prio) we also check whether the current direction equals the direction of our vehicle thread. Those variables are protected with a binary semaphore.

>> C2: What prevents vehicles from opposite directions from crossing the
>> bridge simultaneously?

As already pointed out in C1, this is guaranteed in the critical section of arrive_bridge(int direc, int prio), where each vehicle has to check whether the bridge is empty and no emergency vehicle is waiting or the current direction equals its own direction and again no emergency vehicle is waiting. 

>> C3: How does your solution grant priority to emergency vehicles over
>> the queue of vehicles ahead in the same direction?

This is granted by the fact that each vehicle thread first checks that no emergency vehicle wants to cross the bridge.

>> C4: How do you guarantee that despite having priority, emergency vehicles
>> do not start crossing the bridge while there are still vehicles crossing
>> it in the oposite direction?

This is guaranteed by checking the current direction of the vehicles on the bridge (if there are any). Since this is part of an and-condition, the current direction must equal the direction of the vehicle no matter if it is an emergency vehicle or not. 

>> C5: Explain with examples why your solution does not preserve neither 
>> fairness nor freedom from starvation, other than what has been indicated 
>> for emergency vehicles.

If there are only emergency vehicles and one "normal" vehicle, it will never have the chance to cross the bridge, because the emergency vehicles are always prioritized. So the vehicle will starve.
On the other hand, if there e.g. 10 vehicles driving from left to right and one of them was first allowed to cross the bridge, 5 vehicles that want to drive from right to left will not be allowed to until the others have passed. For that, the solution is also not fair.

---- RATIONALE ----

>> C6: Why did you choose this design? Did you consider other design 
>> alternatives? In what ways is it superior to another design you considered?

No, we didn't consider any alternatives.


			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future semesters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the semester.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

We think that the project is challenging, but not too hard to solve.

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

The assignment as a whole gave us a good insight into operating systems 
beyond the theory discussed in class.

>> Is there some particular fact or hint we should give students in
>> future semesters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

More information on the submission rules would have been nice.

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future semesters or the remaining projects?

-

>> Any other comments?

-