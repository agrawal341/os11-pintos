		     +--------------------------+
		     |            OS            |
		     | PROJECT 2: USER PROGRAMS |
		     |     DESIGN DOCUMENT      |
		     +--------------------------+

---- GROUP ----

Tobias Orth <tobias.orth@gmx.net>
Mirjam Neu-Weigand <mirjam.neuweigand@gmail.com>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

None.

			   ARGUMENT PASSING
			   ================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

None.

---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?

We implemented argument parsing by first counting the number of arguments
and creating tokens for each argument using strtok_r.
Then we allocate an array of the appropriate size where we save the token
pointers. This ensures that the first value in the array equals the first 
element of argv[]. After that, we try to load the file which is given by 
argv[0]. If the load is successful, we push the arguments in reversed order 
on the stack, followed by a word align if necessary. Then we push the required 
sentinel on the stack as well as the argument addresses (argv[i]). Finally, we 
push the argument count and the return address on the user stack.

If an overflow occurs during stack creation, the thread creation is canceled, 
and the -1 is returned.

---- RATIONALE ----

>> A3: Why does Pintos implement strtok_r() but not strtok()?

The reason is that strtok() does not support multi-threading, whereas
strtok_r() supports multithreading by storing information about the next
token in the third argument (save_ptr). This makes it possible to reenter
the string several times.

>> A4: In Pintos, the kernel separates commands into a executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.

1) It is easier to use different shell interfaces.
2) It is an additional protection of the kernel if the shell interprets
   the commands and invokes system calls. If the user has direct access 
   to the kernel there could possibly be a chance to do some malicious
   manipulations.

			     SYSTEM CALLS
			     ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

added to struct thread:
	bool is_user_thread - states if thread is a user thread
	file * executable - file link to the threads code on disk
	thread * parent	- parent of the thread
	list children -	list of child processes which has been started from this thread
	list file_descriptors - list of open files
	uint fd_next_id - next file descriptor id 
	
struct child - child element saved in the children list, including all information about the child process necessary for the current thread

struct file_descriptor_elem - file descriptor element for the fd list, includes all information necessary for file handling


static struct lock filesystem_lock;		- a mutex semaphore for the filesystem, shared by thread.c, process.c and syscall.c 


>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?

Each process keeps track of the files he has opened by managing a file-descriptor
list. This lists includes file_descriptor_elem elements is a data structure which 
saves the opened file and the file descriptor id corresponding to it. The file
descriptor id is unique within a single process.

---- ALGORITHMS ----

>> B3: Describe your code for reading and writing user data from the
>> kernel.

We implemented reading and writing user data according to the first 
mentioned solution in the assignment description. In the method 
syscall_get_argument() we check the validity of a pointer by calling
syscall_get_kernel_address(). If the pointer points to non-user memory 
or is a null pointer the thread is exited. To check if the well bounded
address is mapped we use pagedir_get_page(). Again, the thread is exited
if the region is unmapped. If the look up has been a success, we return 
the kernel virtual address to syscall_get_argument() which returns the 
value at the the address.

>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel.  What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result?  What about
>> for a system call that only copies 2 bytes of data?  Is there room
>> for improvement in these numbers, and how much?

At least 2 calls. As we expect the user stack not being empty (arguments
of the process), we have to copy data to 2 pages. Therefore, we have to 
call get_page() twice, for two different pages.

On the other side, there can be number of byte many page inspections,
simply by checking the page for every byte saving.

One could improve such a page check by knowing the current space left in a 
page, or being informed by the page check if there is a need to check again
as the requested size need another page after x bytes. 

>> B5: Briefly describe your implementation of the "wait" system call
>> and how it interacts with process termination.

The system call wait() invokes process_wait() in process.c. To synchronize
between the caller and the callee, we use a semaphore to let the parent 
process wait until the child is terminated normally or abnormally. In both cases
the semaphore is increased to let the parent process continue its execution.

>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value.  Such accesses must cause the
>> process to be terminated. System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point.  This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling?  Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed?  In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues.  Give an example.

Let us consider the "write" system call as an example. We first implemented
a method "handle_write()" which calls the already mentioned method 
syscall_get_argument(), which fetches the three values at the given address 
if the validity of the user addresses can be proven. In addition, if an
argument itself is a pointer, we check this address as well.
If any of those fail, we exit the program by calling thread_exit(), which 
includes the printout you wished, and releasing all system locks and resources
acquired during the life of the process which has not yet been released.
 
Next, we try to acquire the lock that protects the file system before we fetch 
the requested file descriptor. If the file descriptor is the console, we put the 
bytes that should be written into a buffer. If it should be written to a file, we 
look up the matching file descriptor. If no matching file descriptor could be found, 
we cancel the write call by returning -1. On success, we return the number of bytes
written to the file.
 
---- SYNCHRONIZATION ----

>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading.  How does your code ensure this?  How is the load
>> success/failure status passed back to the thread that calls "exec"?

We implemented a sempaphore waiting. Until the thread started has not
finished its loading step, the caller is not able to continue. If 
the load is not succesfull, the caller is informed. This is achieved by
the child node in the parent list. The child process saves its 
success / fail information in this node. In that way, the parent is
always informed about the child status.

>> B8: Consider parent process P with child process C.  How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits?  After C exits?  How do you ensure
>> that all resources are freed in each case?  How about when P
>> terminates without waiting, before C exits?  After C exits?  Are
>> there any special cases?

As mentioned above, the child process blocks the parents process via
a semaphore until its initialized, normally or abnormally. As the child
node is saved in the parent thread, the node is not removed until the 
parent process itself is terminating. This ensures as well the case that,
if C has already exited, the semaphore has been increased and is still
available. Even if the parent process exits before the child, the child
can check if the its node is still available in the parent thread, if not
nothing has to be saved, as no interdependency exists. Each process is 
therefore only responsible for its own resources, independent it has 
children or not.

---- RATIONALE ----

>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?

We chose to first check the validity of a user pointer before 
dereferencing it because this makes it easier to handle the release of 
locks and allocated memory afterwards. As already pointed out in the 
assignment, you need not to worry about how to return from a page fault. 
So we chose the easier and more flexible technique.

>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?

We designed file descriptors as property of a thread. The thread uses this
file descriptor list to manage all open files. An advantage of this design
is that the kernel can also access the file descriptors list, e.g. if the 
process has to be killed due to an error. The kernel could then free those 
resources.

>> B11: The default tid_t to pid_t mapping is the identity mapping.
>> If you changed it, what advantages are there to your approach?

We did not change it.

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

Its a bit long for a two person group. We had to use all remaining slip
days to come up with a good solution. Maybe a group of 3 would solve 
this particular problem.

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

Everything.

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

No.

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?
 
